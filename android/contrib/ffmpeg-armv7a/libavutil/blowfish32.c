#include <stdlib.h>
#include <memory.h>
#include "blowfish32.h"

#define F(x,t) t = keystruct->s[0][((x) >> 8) & 0xFF]; \
               t ^= keystruct->s[1][(x) & 0xFF];

#define swap(r,l,t) t = l; l = r; r = t;

#define ITERATION(l,r,t,pval) l ^= keystruct->p[pval]; F(l,t); r^= t; swap(r,l,t);


static const uint16_t p_perm[18] = {
    0x243F,0x85A3,0x1319,0x0370,0xA409,0x299F,0x082E,
    0xEC4E,0x4528,0x38D0,0xBE54,0x34E9,0xC0AC,0xC97C,
    0x3F84,0xB547,0x9216,0x8979
};

static const uint16_t s_perm[2][256] = { {
    0xD131,0x98DF,0x2FFD,0xD01A,0xB8E1,0x6A26,0xBA7C,0xF12C,
    0x24A1,0xB391,0x0801,0x858E,0x6369,0x7157,0xA458,0xF493,
    0x0D95,0x728E,0x718B,0x8215,0x7B54,0xC25A,0x9C30,0x2AF2,
    0xC5D1,0x2860,0xCA41,0xB8DB,0x8E79,0x603A,0x6C9E,0xB01E,
    0xD715,0xBD31,0x78AF,0x5560,0xE655,0xAA55,0x5748,0x63E8,
    0x55CA,0x2AAB,0xB4CC,0x1141,0xA154,0x7C72,0xB3EE,0x636F,
    0x2BA9,0x7418,0xCE5C,0x9B87,0xAFD6,0x6C24,0x7A32,0x2895,
    0x3B8F,0x6B4B,0xC4BF,0x6628,0x61D8,0xFB21,0x487C,0x5DEC,
    0xEF84,0xE985,0xDC26,0xEB65,0x2389,0xD396,0x0F6D,0x83F4,
    0x2E0B,0xA484,0x69C8,0x9E1F,0x21C6,0xF6E9,0x670C,0xABD3,
    0x6A51,0xD854,0x960F,0xAB51,0x6EEF,0x137A,0xBA3B,0x7EFB,
    0xA1F1,0x39AF,0x66CA,0x8243,0x8CEE,0x456F,0x7D84,0x3B8B,
    0xE06F,0x85C1,0x401A,0x56C1,0x4ED3,0x363F,0x1BFE,0x429B,
    0x37D0,0xD00A,0xDB0F,0x49F1,0x0753,0x8099,0x25D4,0xF6E8,
    0xE3FE,0xB679,0x976C,0x04C0,0xC1A9,0x409F,0x5E5C,0x196A,
    0x68FB,0x3E6C,0x1339,0x3B52,0x6DFC,0x9B30,0xCC81,0xAF5E,
    0xBEE3,0xDE33,0x660F,0x192E,0xC0CB,0x45C8,0xD20B,0xB9D3,
    0x5579,0x1A60,0xD6A1,0x402C,0x679F,0xFB1F,0x8EA5,0xDB32,
    0x3C75,0xFD61,0x2F50,0xAD05,0x323D,0xFD23,0x5331,0x3E00,
    0x9E5C,0xCA6F,0x1A87,0xDF17,0xD542,0x287E,0xAC67,0x8C4F,
    0x695B,0xBBCA,0xE1FF,0xB8F0,0x10FA,0xFD21,0x4AFC,0x2DD1,
    0x9A53,0xB6F8,0xD28E,0x4BFB,0xE1DD,0xA4CB,0x62FB,0xCEE4,
    0xEF20,0x3677,0xD07E,0x2BF1,0x95DB,0xAE90,0xEAAD,0x6B93,
    0xD08E,0xAFC7,0x8E3C,0x8E75,0x8FF6,0xF212,0x8888,0x900D,
    0x4FAD,0x688F,0xD1CF,0xB3A8,0x2F2F,0xBE0E,0xEA75,0x8B02,
    0xE5A0,0xB56F,0x18AC,0xCE89,0xB4A8,0xFD13,0x7CC4,0xD2AD,
    0x165F,0x8095,0x93CC,0x211A,0xE6AD,0x77B5,0xC754,0xFB9D,
    0xEBCD,0x7B3E,0xD641,0xAE1E,0x0025,0x2071,0x2268,0x57B8,
    0x2464,0xF009,0x5563,0x59DF,0x78C1,0xD95A,0x207D,0x02E5,
    0x8326,0x6295,0x11C8,0x4E73,0xB347,0x7B14,0x1B51,0x9A53,
    0xD60F,0xBC9B,0x2B60,0x81E6,0x08BA,0x571B,0xF296,0x2A0D,
    0xB663,0xE7B9,0xFF34,0xC585,0x53B0,0xA99F,0x08BA,0x6E85
},{
    0x4B7A,0xB5B3,0xDB75,0xC419,0xAD6E,0x49A7,0x9CEE,0x8FED,
    0xECAA,0x699A,0x5664,0xC2B1,0x1936,0x7509,0xA059,0xE418,
    0x3F54,0x5B42,0x6B8F,0x99F7,0xA1D2,0xEFE8,0x4D2D,0xF025,
    0x4CDD,0x8470,0x6382,0x021E,0x0968,0x3EBA,0x3C97,0x6B6A,
    0x687F,0x52A0,0xB79C,0xAA50,0x3E07,0x7FDE,0x8E7D,0x5716,
    0xB03A,0xF050,0xF01C,0x0200,0xAE0C,0x3CB5,0x2583,0xDC09,
    0xD191,0x7CA9,0x9432,0x22F5,0x3AE5,0x37C2,0xC8B5,0x9AF3,
    0xA944,0x0FD0,0xECC8,0xA475,0xE238,0x3BEA,0x3280,0x183E,
    0x4E54,0x4F6D,0x6F42,0xF60A,0x2CB8,0x2497,0x5679,0xBCAF,
    0xDE9A,0xD993,0xB38B,0xDCCF,0x5512,0x2E6B,0x501A,0x9F84,
    0x7A58,0x7408,0xBC9F,0xE94B,0xEC7A,0xDB85,0x6309,0xC464,
    0xEF1C,0x3215,0xDD43,0x24C2,0x12A1,0x2A65,0x5094,0x133A,
    0x71DF,0x1031,0x81AC,0x5F11,0x0435,0xD7A3,0x3C11,0x5924,
    0xF28F,0x97F1,0x9EBA,0x1E15,0x86E3,0xEAE9,0x860E,0x5A3E,
    0x771F,0x4E3D,0x2965,0x99E7,0x803E,0x5266,0x2E4C,0x9C10,
    0xC615,0x94E2,0xA5FC,0x1E0A,0xF2F7,0x361D,0x1939,0x19C2,
    0x5223,0xF713,0xEBAD,0xEAC3,0xE3BC,0xA67B,0xB17F,0x018C,
    0xC332,0xBE6C,0x6558,0x68AB,0xEECE,0xDB2F,0x2AEF,0x5B6E,
    0x1521,0x2907,0xECDD,0x619F,0x13CC,0xEB61,0x0334,0xAA03,
    0xB573,0x4C70,0xD59E,0xCBAA,0xEECC,0x6062,0x9CAB,0xB2F3,
    0x648B,0x19BD,0xA023,0x655A,0x4068,0x3C2A,0x319E,0xC021,
    0x9B54,0x875F,0x95F7,0x623D,0xF837,0x97E3,0x11ED,0x1668,
    0x0E35,0xC7E6,0x96DE,0x7858,0x57F5,0x1B22,0x9B83,0x1AC2,
    0xCDB3,0x532E,0x8FD9,0x6DBC,0x58EB,0x34C6,0xFE28,0xEE7C,
    0x5D4A,0xE864,0x4210,0x203E,0x45EE,0xA3AA,0xDB6C,0xFACB,
    0xC742,0xEF6A,0x654F,0x41CD,0xD81E,0x8685,0xE44B,0x3D81,
    0xCF62,0x5B8D,0xFC88,0xC1C7,0x7F15,0x69CB,0x4784,0x5692,
    0x095B,0xAD19,0x1462,0x2382,0x5842,0x0C55,0x1DAD,0x233F,
    0x3372,0x8D93,0xD65F,0x6C22,0x7CDE,0xCBEE,0x4085,0xCE77,
    0xA607,0x19F8,0xE8EF,0x61D9,0xA969,0xC50C,0x5A04,0x800B,
    0x9E44,0xC345,0xFDD5,0x0E1E,0xDB73,0x1055,0x675F,0xE367,
    0xC5C4,0x713E,0x3D28,0xF16D,0x153E,0x8FB0,0xE6E3,0xDB83
} };


int blowfish_encrypt(const BLOWFISH_CTX *keystruct, const uint8_t in[], uint8_t out[], int blockcnt)
{
    if(keystruct==NULL){
        return -1;
    }
    for (int k=0; k<blockcnt; k++) {
        uint16_t l, r, t=0;
        int index0 = 0 + k*BLOWFISH_BLOCK_SIZE;
        int index1 = 1 + k*BLOWFISH_BLOCK_SIZE;
        int index2 = 2 + k*BLOWFISH_BLOCK_SIZE;
        int index3 = 3 + k*BLOWFISH_BLOCK_SIZE;
        l = (in[index0] << 8) | (in[index1]);
        r = (in[index2] << 8) | (in[index3]);
        int loop = keystruct->loops;
        int count = (loop<=16&&loop>=1)?loop:16;
        int i = 0;
        for( ; i<=(count-2); i++){
            ITERATION(l,r,t,i);
        }
        l ^= keystruct->p[i]; F(l,t); r^= t;
        r ^= keystruct->p[i+1];
        l ^= keystruct->p[i+2];
        out[index0] = l >> 8;
        out[index1] = l;
        out[index2] = r >> 8;
        out[index3] = r;
    }
    return 0;
}

int blowfish_decrypt(const BLOWFISH_CTX *keystruct, const uint8_t in[], uint8_t out[], int blockcnt)
{
    if(keystruct==NULL){
        return -1;
    }
    for (int k=0; k<blockcnt; k++) {
        uint16_t l, r, t=0;
        int index0 = 0 + k*BLOWFISH_BLOCK_SIZE;
        int index1 = 1 + k*BLOWFISH_BLOCK_SIZE;
        int index2 = 2 + k*BLOWFISH_BLOCK_SIZE;
        int index3 = 3 + k*BLOWFISH_BLOCK_SIZE;
        l = ((in[index0] << 8) | (in[index1]));
        r = ((in[index2] << 8) | (in[index3]));
        int loop = keystruct->loops;
        int count = (loop<=16&&loop>=1)?loop:16;
        int i = count+1;
        for (; i>=3; i--) {
            ITERATION(l, r, t, i);
        }
        l ^= keystruct->p[i]; F(l,t); r^= t;
        r ^= keystruct->p[i-1];
        l ^= keystruct->p[i-2];

        out[index0] = l >> 8;
        out[index1] = l;
        out[index2] = r >> 8;
        out[index3] = r;
    }
    return 0;
}

void blowfish_init(const uint8_t* user_key, int len, int loops, BLOWFISH_CTX *keystruct)
{
    memcpy(keystruct->p, p_perm, sizeof(p_perm));
    memcpy(keystruct->s, s_perm, sizeof(s_perm));
    keystruct->loops = loops;
    
    //recalculate blowfish keys by user key
    for (int i=0; i<sizeof(keystruct->p)/sizeof(uint16_t); i++) {
        keystruct->p[i] = (keystruct->p[i]&0xFF00)|(user_key[i%len]&0x00FF);
    }
    
    for (int j=0; j<2; j++) {
        for (int i=0; i<sizeof(keystruct->s[j])/sizeof(uint16_t); i++) {
            uint16_t high = user_key[i%len];
            keystruct->s[j][i] = (keystruct->s[j][i]&0x00FF)|(high<<8);
        }
    }
}
